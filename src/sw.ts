/// <reference lib="webworker" />
/// <reference types="vite-plugin-pwa/client" />
import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

declare let self: ServiceWorkerGlobalScope;

// Background Sync types
interface SyncEvent extends ExtendableEvent {
  readonly tag: string;
  readonly lastChance: boolean;
}

// Extended notification options (browser support varies)
interface ExtendedNotificationOptions extends NotificationOptions {
  image?: string;
  actions?: NotificationAction[];
  timestamp?: number;
  vibrate?: number[];
}

interface NotificationAction {
  action: string;
  title: string;
  icon?: string;
}

// ==========================================
// WORKBOX CONFIGURATION
// ==========================================

// Skip waiting and claim clients immediately
self.skipWaiting();
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by Vite
// The __WB_MANIFEST placeholder is replaced by VitePWA with the actual precache manifest
precacheAndRoute(self.__WB_MANIFEST);

// Handle navigation requests with the app shell
const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler, {
  // Don't handle API routes or auth callbacks
  denylist: [/^\/api/, /^\/auth/],
});
registerRoute(navigationRoute);

// Cache API responses with Network First strategy
registerRoute(
  /^https:\/\/api\./i,
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  }),
  'GET'
);

// Cache images with Cache First strategy
registerRoute(
  /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// ==========================================
// PUSH NOTIFICATIONS
// ==========================================

// Debug mode
const DEBUG = false;

interface PushNotificationPayload {
  title?: string;
  body?: string;
  icon?: string;
  badge?: string;
  image?: string;
  tag?: string;
  requireInteraction?: boolean;
  data?: {
    url?: string;
    [key: string]: unknown;
  };
  actions?: NotificationAction[];
}

// Handle push notifications
self.addEventListener('push', (event: PushEvent) => {
  if (DEBUG) console.log('[Service Worker] Push received:', event);

  let notificationData: PushNotificationPayload = {
    title: 'PattaMap Notification',
    body: 'You have a new notification',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    data: {
      url: '/',
    },
  };

  // Parse notification payload
  if (event.data) {
    try {
      const payload = event.data.json() as PushNotificationPayload;
      if (DEBUG) console.log('[Service Worker] Push payload:', payload);

      notificationData = {
        title: payload.title || notificationData.title,
        body: payload.body || notificationData.body,
        icon: payload.icon || notificationData.icon,
        badge: payload.badge || notificationData.badge,
        image: payload.image,
        tag: payload.tag || 'pattamap-notification',
        requireInteraction: payload.requireInteraction || false,
        data: payload.data || notificationData.data,
        actions: payload.actions || [],
      };
    } catch (error) {
      console.error('[Service Worker] Error parsing push payload:', error);
    }
  }

  // Show notification with extended options
  const options: ExtendedNotificationOptions = {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    image: notificationData.image,
    tag: notificationData.tag,
    requireInteraction: notificationData.requireInteraction,
    data: notificationData.data,
    actions: notificationData.actions,
    vibrate: [200, 100, 200],
    timestamp: Date.now(),
  };

  event.waitUntil(
    self.registration.showNotification(notificationData.title!, options as NotificationOptions)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  if (DEBUG) console.log('[Service Worker] Notification click:', event);

  event.notification.close();

  // Get the URL to open
  const urlToOpen = (event.notification.data?.url as string) || '/';

  // Handle action button clicks
  if (event.action) {
    if (DEBUG) console.log('[Service Worker] Action clicked:', event.action);
  }

  // Open or focus the app window
  event.waitUntil(
    self.clients
      .matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Check if app is already open
        for (const client of clientList) {
          if (client.url.includes(urlToOpen) && 'focus' in client) {
            return client.focus();
          }
        }

        // Open new window if app is not open
        if (self.clients.openWindow) {
          return self.clients.openWindow(urlToOpen);
        }
      })
  );
});

// Handle notification close
self.addEventListener('notificationclose', (event: NotificationEvent) => {
  if (DEBUG) console.log('[Service Worker] Notification closed:', event);
});

// ==========================================
// BACKGROUND SYNC (Offline Queue)
// ==========================================

const DB_NAME = 'pattamap-offline';
const DB_VERSION = 1;
const STORE_NAME = 'request-queue';

interface QueuedRequest {
  id: string;
  url: string;
  method: string;
  headers?: Record<string, string>;
  body?: unknown;
  timestamp: number;
  retryCount: number;
  maxRetries: number;
}

function openQueueDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        store.createIndex('timestamp', 'timestamp', { unique: false });
      }
    };
  });
}

async function getQueuedRequests(): Promise<QueuedRequest[]> {
  const db = await openQueueDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();

    request.onsuccess = () => resolve(request.result || []);
    request.onerror = () => reject(request.error);
  });
}

async function removeFromQueue(id: string): Promise<void> {
  const db = await openQueueDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.delete(id);

    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

async function updateRetryCount(id: string): Promise<QueuedRequest | null> {
  const db = await openQueueDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const getRequest = store.get(id);

    getRequest.onsuccess = () => {
      const request = getRequest.result as QueuedRequest | undefined;
      if (!request) {
        resolve(null);
        return;
      }

      request.retryCount = (request.retryCount || 0) + 1;
      const putRequest = store.put(request);
      putRequest.onsuccess = () => resolve(request);
      putRequest.onerror = () => reject(putRequest.error);
    };
    getRequest.onerror = () => reject(getRequest.error);
  });
}

async function processOfflineQueue(): Promise<{ success: number; failed: number }> {
  if (DEBUG) console.log('[Service Worker] Processing offline queue...');

  try {
    const requests = await getQueuedRequests();
    if (DEBUG) console.log(`[Service Worker] Found ${requests.length} queued requests`);

    let success = 0;
    let failed = 0;

    for (const queuedRequest of requests) {
      if (queuedRequest.retryCount >= (queuedRequest.maxRetries || 3)) {
        console.warn('[Service Worker] Max retries exceeded for:', queuedRequest.id);
        await removeFromQueue(queuedRequest.id);
        failed++;
        continue;
      }

      try {
        const response = await fetch(queuedRequest.url, {
          method: queuedRequest.method,
          headers: {
            'Content-Type': 'application/json',
            ...(queuedRequest.headers || {}),
          },
          body: queuedRequest.body ? JSON.stringify(queuedRequest.body) : undefined,
          credentials: 'include',
        });

        if (response.ok) {
          await removeFromQueue(queuedRequest.id);
          success++;
          if (DEBUG) console.log('[Service Worker] Request succeeded:', queuedRequest.id);
        } else {
          await updateRetryCount(queuedRequest.id);
          failed++;
          console.warn('[Service Worker] Request failed:', response.status);
        }
      } catch (error) {
        await updateRetryCount(queuedRequest.id);
        failed++;
        console.error('[Service Worker] Request error:', error);
      }
    }

    if (DEBUG) console.log(`[Service Worker] Queue processed: ${success} success, ${failed} failed`);

    // Notify all clients about sync completion
    const allClients = await self.clients.matchAll({ type: 'window' });
    for (const client of allClients) {
      client.postMessage({
        type: 'SYNC_COMPLETE',
        payload: { success, failed },
      });
    }

    return { success, failed };
  } catch (error) {
    console.error('[Service Worker] Failed to process queue:', error);
    throw error;
  }
}

// Background Sync Event Handler
// Note: Background Sync API may not be available in all browsers
self.addEventListener('sync', ((event: SyncEvent) => {
  if (DEBUG) console.log('[Service Worker] Background sync:', event.tag);

  if (event.tag === 'offline-queue') {
    event.waitUntil(processOfflineQueue());
  }
}) as EventListener);

// Handle messages from the main app
self.addEventListener('message', (event: ExtendableMessageEvent) => {
  if (DEBUG) console.log('[Service Worker] Message received:', event.data);

  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

if (DEBUG) console.log('[Service Worker] Loaded with push notifications support');
